# -*- coding: utf-8 -*-
"""
/***************************************************************************
 bcStackP3
                           A QGIS Processing algorithm
                       Create a stacked line vector layer

 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-05-19
        copyright            : (C) 2019-2023 by GeoProc.com
        email                : info@geoproc.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
WARNING: code formatting does not follow pycodestyle recommendations
"""

__author__ = 'GeoProc.com'
__date__ = '2019-05-19'
__copyright__ = '(C) 2019-2023 by GeoProc.com'
__revision__ = '$Format:%H$'

import os
import codecs
is_dependencies_satisfied = False
from math import sin, cos, radians, sqrt
try:
    import numpy as np
    import pandas as pd
    is_dependencies_satisfied = True
except:
    try:
        os.system('"' + os.path.join(sys.prefix, 'scripts', 'pip.exe') + '" install pandas')
    finally:
        import pandas as pd
        is_dependencies_satisfied = True

from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtCore import QVariant
from qgis.core import (QgsFeature,
                       QgsFeatureRequest,
                       QgsFeatureSink,
                       QgsField,
                       QgsFields,
                       QgsGeometry,
                       QgsLineString,
                       QgsPoint,
                       QgsProcessing,
                       QgsProcessingAlgorithm,
                       QgsProcessingException,
                       QgsProcessingFeatureSource,
                       QgsProcessingUtils,
                       QgsStatisticalSummary,
                       QgsWkbTypes)

from .setparams import set_param
from .HelpbcA import help_bcStackP
#-----------------------------------------------------------------------------------------
plugin_path = os.path.dirname(__file__)

the_url = 'https://www.geoproc.com/be/bcStackP3.htm'
help_string = help_bcStackP
the_tags = ['geophysics','line','stacked','profile','vector','magnetic','electromagnetic',
            'gravity','electrical','radiometric','2D','survey']
#-----------------------------------------------------------------------------------------

class bcStackPAlgorithm(QgsProcessingAlgorithm):
    ''' Processing wrapper for the colour scale bar algorithm. '''
    #
    # Parameters used for stacking profiles
    __bcname__ = 'bcStackP3'
    THE_LAYER = 'THE_LAYER'
    FID_FLD   = 'FID_FLD'
    DATA_FLD  = 'DATA_FLD'
    LINE_FLD  = 'LINE_FLD'
    DUMVAL    = 'DUMVAL'
    INVERTP   = 'INVERTP'
    SCALE     = 'SCALE'
    OFFSET    = 'OFFSET'
    JOINL     = 'JOINL'
    OUTPUT    = 'OUTPUT'
    BSCALE    = 'BSCALE'
    SCALLY    = 'SCALLY'
    SCALCH    = 'SCALCH'
    DEP       = 'DEP'

    _default_output = 'stacked profiles_ln'

    _ico = 'bcStackP'
    _the_strings = {"ERR":"ERROR",
                    "ERR_DEP":"numpy and pandas are required to run this algorithm",
                    "DEP_LST":"numpy, pandas",
                    "ERR_VECTOR":"ERROR: Input is not a vector!",
                    "ALGONAME":"Stacked profiles from point layer"
                   }

    _pstr = ['Input vector (point layers only. NO multipoint or otherwise)', #  0
             'Fiducial field (monotonically increasing number)',             #  1
             'Data field (numeric)',                                         #  2
             'Line field',                                                   #  3
             'Dummy (N/A) value',                                            #  4
             'Reverse profiles?',                                            #  5
             'Profile scale (relative to longest line length)',              #  6
             'Profile offset (relative to base line, +/-)',                  #  7
             'Join profile to line?',                                        #  8
             'Do scaling relative to another channel?',                      #  9
             'Scaling layer',                                                # 10
             'Scaling channel',                                              # 11
             'Output: Stacked profile vector file',                          # 12
             'Output line vector file']                                      # 13

    def __init__(self):
        super().__init__()
    #-------------------------------------------------------------------------------------

    def _define_params(self):
        ''' Define parameters needed. '''
        #
        #       [0] < 100  : "normal" parameter
        # 100 < [0] < 1000 : Advanced Parameter
        #       [0] > 1000 : Output parameter
        self.the_params = {
           self.THE_LAYER: [1,self._pstr[0],'VectorLayer',
                            {'types':[QgsProcessing.TypeVectorPoint]},False],
           self.FID_FLD:   [2,self._pstr[1],'Field',{'parent':self.THE_LAYER},False],
           self.LINE_FLD:  [3,self._pstr[3],'Field',{'parent':self.THE_LAYER},False],
           self.DATA_FLD:  [4,self._pstr[2],'Field',{'parent':self.THE_LAYER},False],
           self.DUMVAL:    [5,self._pstr[4],'NumberD',
                            {'defaultValue':9999.,'minValue':-1e5,'maxValue':1e5},True],
           self.INVERTP:   [6,self._pstr[5],'Bool',{'defaultValue':False},True],
           self.SCALE:     [7,self._pstr[6],'NumberD',
                            {'defaultValue':3,'minValue':.0005,'maxValue':2000},True],
           self.OFFSET:    [8,self._pstr[7],'NumberD',
                            {'defaultValue':0.,'minValue':-1e5,'maxValue':1e5},True],
           self.JOINL:     [9,self._pstr[8],'Bool',{'defaultValue':False},True],
           self.BSCALE:    [109,self._pstr[9],'Bool',{'defaultValue':False},True],
           self.SCALLY:    [110,self._pstr[10],'VectorLayer',
                            {'types':[QgsProcessing.TypeVectorPoint]},True],
           self.SCALCH:    [111,self._pstr[11],'Field',{'parent':self.THE_LAYER},True],
           self.OUTPUT:    [1001,self._pstr[12],'SINK',
                            {'type':QgsProcessing.TypeVectorLine,
                             'defaultValue':self._default_output},True]
        }
        self._err_param = {self.DEP: [1,self._the_strings["ERR_DEP"],'String',
                           {'defaultValue':self._the_strings["DEP_LST"]},False]}
    #-------------------------------------------------------------------------------------

    def initAlgorithm(self, config):
        ''' Here we define the inputs and output of the algorithm. '''
        #
        self._define_params()
        if is_dependencies_satisfied:
            # Prepare all parameters needed
            for param in sorted(self.the_params, key=self.the_params.__getitem__):
                b = self.the_params[param][0]
                qparam = set_param(param, self.the_params)
                if qparam != None:
                    if b < 100:
                        self.addParameter(qparam)
                    elif b < 1000:
                        self.addParameter((qparam))
                    else:
                        self.addParameter(qparam, True)

        else:
            qparam = set_param(self.DEP, self._err_param)
            self.addParameter(qparam)

        self.tmpDir  = QgsProcessingUtils.tempFolder()
        self._error  = ''
        self.azi     = None
        self.aziT    = None
        self.type    = 'L'
        self.azimut  = None
        self.length  = 0.
        self.clength = 0.
    #-------------------------------------------------------------------------------------

    def _do_profile(self, ar, inv, scale, offset):
        ''' Create profile for current line.
            ar: current line (pandas DataFrame)
            inv: 1 (default) or -1 to reverse profile
            scale: scale profile relative to max-profile length
            offset: move profile relative to line trace

            Return: 2 numpy arrays: X and new-Y = profile coordinates
        '''
        #
        nar = np.array(ar[['X','Y']])
        line_pts = [QgsPoint(x,y) for x,y in nar]

        # Rotate line to horizontal
        aziN   = line_pts[0].azimuth(line_pts[-1]) # angle positive clockwise from North
        azi    = 90. -aziN                         # angle +'ve CCW from East
        cx, cy = nar[0, 0], nar[0, 1]              # center of rotation

        # Rotate line to horizontal    
        theta  = radians(-azi)
        co, si = cos(theta), sin(theta)
        tx, ty = nar[:,0] - cx, nar[:,1] - cy
        px = tx * co - ty * si + cx
        py = tx * si + ty * co + cy

        # Take care of profile direction and line vs tie-line
        bT = False
        self.type = 'L'
        if self.azi != None and abs(int(azi) - self.azi) > 20:
            if ((azi > self.azi and abs(int(azi) - (self.azi +180)) < 20) or
                (azi < self.azi and abs(int(azi) - (self.azi -180)) < 20)):
                inv = -inv
            elif self.aziT == None:
                # first tie line
                self.aziT = int(azi)
                bT = True
            if self.aziT != None and abs(int(azi) - self.aziT) > 20:
                if ((azi > self.aziT and abs(int(azi) - (self.aziT +180)) < 20) or
                    (azi < self.aziT and abs(int(azi) - (self.aziT -180)) < 20)):
                    inv = -inv
                    bT = True
            elif self.aziT != None and abs(int(azi) - self.aziT) <= 20:
                    bT =True
        if bT:
            inv = -inv
            self.type = 'T'
        # Change Y-coords to scaled data
        mn = py.mean()  # average Y-coord
        ar['Yb'] = inv * (scale * (ar.Data - self.dmean) * self.mult + offset) + mn

        # Rotate line back to original angle
        theta  = radians(azi)
        co, si = cos(theta), sin(theta)
        tx, ty = px - cx, np.array(ar.Yb) - cy
        px1 = tx * co - ty * si + cx   # New X-coords
        py1 = tx * si + ty * co + cy   # New Y-coords
        #
        self.azimut = aziN
        self.length = line_pts[0].distance(line_pts[-1])
        self.clength = np.array([line_pts[i].distance(line_pts[i+1]) 
                                                   for i in range(len(line_pts)-1)]).sum()
        #
        if self.azi == None:
            self.azi = int(azi)
        return px1, py1  # profile coords
    #-------------------------------------------------------------------------------------

    def processAlgorithm(self, parameters, context, feedback):
        ''' Here is where the processing itself takes place. '''
        #
        if not is_dependencies_satisfied:
            return {}

# Init
        # The number of features in the input layer could be trimmed to user selection.
        the_layer = self.parameterAsSource(parameters, self.THE_LAYER, context)
        gok = QgsWkbTypes.geometryType(the_layer.wkbType()) == QgsWkbTypes.PointGeometry
        if the_layer is None or not gok:
            raise QgsProcessingException(self.invalidSourceError(parameters,
                                                                 self.THE_LAYER))
        #
        bCHscal = self.parameterAsBool(parameters, self.BSCALE, context)
        if bCHscal:
            # Use another channel for scaling. All data from that channel will be used.
            scally = self.parameterAsSource(parameters, self.SCALLY, context)
            if scally is None or the_layer.wkbType() != QgsWkbTypes.Point:
                raise QgsProcessingException(self.invalidSourceError(parameters,
                                                                     self.SCALLY))
        fidu_fld     = self.parameterAsString(parameters, self.FID_FLD, context)
        data_fld     = self.parameterAsString(parameters, self.DATA_FLD, context)
        line_fld     = self.parameterAsString(parameters, self.LINE_FLD, context)
        invP         = self.parameterAsBool(parameters,   self.INVERTP, context)
        dumval       = self.parameterAsDouble(parameters, self.DUMVAL, context)
        scale        = self.parameterAsDouble(parameters, self.SCALE, context)
        offset       = self.parameterAsDouble(parameters, self.OFFSET, context)
        join_to_line = self.parameterAsBool(parameters,   self.JOINL, context)

        data = the_layer.fields().at(the_layer.fields().lookupField(data_fld))
        fidu = the_layer.fields().at(the_layer.fields().lookupField(fidu_fld))
        if not data.isNumeric() or not fidu.isNumeric():
            raise QgsProcessingException(self.invalidSourceError(parameters,
                                                             self.THE_LAYER))

        line = the_layer.fields().at(the_layer.fields().lookupField(line_fld))
        data_ix = the_layer.fields().lookupField(data_fld)
        line_ix = the_layer.fields().lookupField(line_fld)
        fidu_ix = the_layer.fields().lookupField(fidu_fld)

        # Set output vector layer: point(X, Y, M) M is data value at that point
        output_wkb = QgsWkbTypes.LineString
        output_wkb = QgsWkbTypes.addM(output_wkb)

        # Fields of stacked profiles vector
        line_def = the_layer.fields().at(line_ix)
        fields = QgsFields()
        if line_def is not None:
            fields = QgsFields()
            fields.append(QgsField('Line', QVariant.String, '', 16))
            fields.append(QgsField('Type', QVariant.String, '', 2))
            fields.append(QgsField('NbPts', QVariant.Int, '', 10, 0))
            fields.append(QgsField('Azimuth', QVariant.Double, '', 10, 6))
            fields.append(QgsField('DistEP', QVariant.Double, '', 10, 2))
            fields.append(QgsField('Length', QVariant.Double, '', 10, 2))
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT, context, fields,
                                               output_wkb, the_layer.sourceCrs())
        if sink is None:
            raise QgsProcessingException(self.invalidSinkError(parameters, self.OUTPUT))

        # Get the features and fields of interest
        features = the_layer.getFeatures(QgsFeatureRequest().setSubsetOfAttributes(
                       [fidu_ix, line_ix, data_ix]), 
                       QgsProcessingFeatureSource.FlagSkipGeometryValidityChecks)

# CSV
        # Find min/max of data values for all lines and save each line in a csv file
        # Then process each line separately: can have any number of lines...
        lines = []
        xyzf  = []
        lineN = ''
        nL    = 0
        TL    = 0.
        total = 60.0 / the_layer.featureCount() if the_layer.featureCount() else 0
        stat  = QgsStatisticalSummary()
        for current, ft in enumerate(features):
            if feedback.isCanceled():
                break
            feedback.setProgress(int(current * total))
            if not ft.hasGeometry():
                continue
            #
            if ft[line.name()] != lineN:
                if xyzf != []:
                    lines.append([lineN, nL])
                    the_csv = os.path.join(self.tmpDir, '%s.csv' % str(lineN))
                    with codecs.open(the_csv, 'w', 'utf-8') as fo:
                        fo.write('X,Y,FID,Data\n')
                        for ar in xyzf:
                            fo.write(','.join(map(str, ar)))
                            fo.write('\n')
                    le = sqrt((xyzf[0][0] - xyzf[-1][0])**2 + 
                              (xyzf[0][1] - xyzf[-1][1])**2)
                    if le > TL:
                        TL = le
                    xyzf = []
                    nL = 0
                lineN = ft[line.name()]
            #
            rdata = float(ft[data.name()])
            fiduu = int(ft[fidu.name()])
            if abs(rdata - dumval) < 1e-6:
                # Dummy value: skip
                continue
            #
            stat.addVariant(ft[data.name()])
            # how to handle QgsMultiPoint ???
            if (the_layer.wkbType() == QgsWkbTypes.MultiPoint or
                the_layer.wkbType() == QgsWkbTypes.MultiPointM or
                the_layer.wkbType() == QgsWkbTypes.MultiPointZ or
                the_layer.wkbType() == QgsWkbTypes.MultiPointZM or
                the_layer.wkbType() == QgsWkbTypes.MultiPoint25D):
                # Suppose they all have the same attributes:
                #  in this case it seems useless to get more than the first point, but...
                points = ft.geometry().constGet().clone()
            else:
                points = [ft.geometry().constGet().clone()]
            try:
                for point in points:
                    xyzf.append([point.x(), point.y(), fiduu, rdata])
                    nL += 1
            except:
                pass
        # last line
        if xyzf != []:
            lines.append([lineN, nL])
            the_csv = os.path.join(self.tmpDir, '%s.csv' % str(lineN))
            with codecs.open(the_csv, 'w', 'utf-8') as fo:
                fo.write('X,Y,FID,Data\n')
                for ar in xyzf:
                    fo.write(','.join(map(str, ar)))
                    fo.write('\n')
            le = sqrt((xyzf[0][0] - xyzf[-1][0])**2 + 
                      (xyzf[0][1] - xyzf[-1][1])**2)
            if le > TL:
                TL = le
        #
        stat.finalize()
        self.dmean = stat.mean()
        self.mult = TL / (stat.max() - stat.min())
        #
        if bCHscal:
            # Scaling field: retrieve its stats
            scch_fld = self.parameterAsString(parameters, self.SCALCH, context)
            scch     = scally.fields().at(scally.fields().lookupField(scch_fld))
            scch_ix  = scally.fields().lookupField(scch_fld)
            scch_f   = scally.getFeatures(QgsFeatureRequest().setSubsetOfAttributes(
                           [scch_ix]), 
                           QgsProcessingFeatureSource.FlagSkipGeometryValidityChecks)
            stat  = QgsStatisticalSummary()
            for current, ft in enumerate(scch_f):
                stat.addVariant(ft[scch.name()])
            stat.finalize()
            self.dmean = stat.mean()
            self.mult = TL / (stat.max() - stat.min())
        #
        if invP:
            iv = -1
        else:
            iv = 1

# Profile
        total = 40.0 / (len(lines) + 1)
        # For each line:
        for current, z in enumerate(lines):
            line = z[0]
            if feedback.isCanceled():
                break
            if not ft.hasGeometry():
                continue
            feedback.setProgress(int(current * total) + 60.)

            # Read line back from csv
            the_csv = os.path.join(self.tmpDir, '%s.csv' % str(line))
            if not os.path.exists(the_csv):
                raise ValueError('It seems parameters are swaped: LINE <-> DATA!')

            ar = pd.read_csv(the_csv)
            ar = ar.sort_values('FID')

            # Create the profile
            px, py = self._do_profile(ar, iv, scale, offset)

            #Construct vector layer
            f = QgsFeature()
            typeL  = str(self.type)
            azimut = float(self.azimut)
            Len    = float(self.length)
            CLen   = float(self.clength)
            f.setAttributes([str(line), typeL, int(len(px)), azimut, Len, CLen])
            line_pts = [QgsPoint(x,y, m=m) for x,y, m in zip(px, py, ar.Data)]
            if join_to_line:
                # Join profile to its line
                e = len(ar) - 1
                ar0 = [QgsPoint(ar.X[0],ar.Y[0], m=0.)]
                ar1 = [QgsPoint(ar.X[e],ar.Y[e], m=0.)]
                line_pts = ar0 + line_pts + ar1
            #
            f.setGeometry(QgsGeometry(QgsLineString(line_pts)))
            sink.addFeature(f, QgsFeatureSink.FastInsert)
            # Delete temp csv file
            try:
                os.remove(the_csv)
            except:
                pass

        return {self.OUTPUT:dest_id}
    #-------------------------------------------------------------------------------------

    def get_error(self):
        ''' Return the error value. '''
        #
        return self.tr(self._error)
    #-------------------------------------------------------------------------------------

    def icon(self):
        ''' Returns a QIcon for the algorithm. '''
        #
        return QIcon(os.path.join(os.path.join(plugin_path, 'res', self._ico+'.svg')))
    #-------------------------------------------------------------------------------------

    def svgIconPath(self):
        ''' Returns a path to an SVG version of the algorithm's icon. '''
        #
        return QIcon(os.path.join(os.path.join(plugin_path, 'res', self._ico+'.svg')))
    #-------------------------------------------------------------------------------------

    def helpUrl(self):
        ''' Returns a url pointing to the algorithm's help page. '''
        #
        return the_url
    #-------------------------------------------------------------------------------------

    def shortHelpString(self):
        ''' Returns a localised short helper string for the algorithm. '''
        #
        return self.tr(help_string)
    #-------------------------------------------------------------------------------------

    def name(self):
        '''
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        '''
        return 'bcStackP3'
    #-------------------------------------------------------------------------------------

    def displayName(self):
        '''
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        '''
        return self.tr(self._the_strings["ALGONAME"])
    #-------------------------------------------------------------------------------------

    def tags(self):
        return self.tr(the_tags)
    #-------------------------------------------------------------------------------------

    def group(self):
        '''
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        '''
        return str(self.groupId()).capitalize()
    #-------------------------------------------------------------------------------------

    def groupId(self):
        '''
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        '''
        return 'vector'
    #-------------------------------------------------------------------------------------

    def tr(self, string):
        ''' No translation of strings. '''
        #
        return string
    #-------------------------------------------------------------------------------------

    def createInstance(self):
        ''' Creates a new instance of the algorithm class. '''
        #
        return bcStackPAlgorithm()
    #-------------------------------------------------------------------------------------